<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叶千铭的博客</title>
  <subtitle>Wer Großes will, muß sich zusammenraffen.  In der Beschränkung zeigt sich erst der Meister,  Und das Gesetz nur kann uns Freiheit geben. </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yeqianming.github.io/"/>
  <updated>2017-03-29T08:36:47.000Z</updated>
  <id>https://yeqianming.github.io/</id>
  
  <author>
    <name>叶千铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongodb aggregate</title>
    <link href="https://yeqianming.github.io/2017/03/29/mongodb-aggregate/"/>
    <id>https://yeqianming.github.io/2017/03/29/mongodb-aggregate/</id>
    <published>2017-03-29T08:05:33.000Z</published>
    <updated>2017-03-29T08:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>需求：删除mongodb中重复的“阶段数据”,阶段表中大概有近百万数据。</p>
<p>方案：按照 “orderid、stepname 分组”，并统计分组中条目数量，筛选出数量大于1的结果，并且按照“createdate”排序。</p>
</blockquote>
<h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CMD:db.col.step.find()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;_id&quot; : ObjectId(&quot;58cfaec9f2aeba9d23c2796f&quot;),</div><div class="line">&quot;Step&quot; : &quot;Purchasing&quot;,</div><div class="line">&quot;OrderId&quot; : NumberInt(&quot;11853559&quot;),</div><div class="line">&quot;PurchaseType&quot; : &quot;Agent&quot;,</div><div class="line">&quot;ShipmentTypeId&quot; : NumberInt(&quot;7&quot;),</div><div class="line">&quot;CustomerId&quot; : NumberInt(&quot;646340&quot;),</div><div class="line">&quot;CatalogCode&quot; : &quot;SG&quot;,</div><div class="line">&quot;OriginCode&quot; : &quot;CN&quot;,</div><div class="line">&quot;CreateDate&quot; : NumberLong(&quot;1490005705&quot;),</div><div class="line">&quot;UpdateDate&quot; : NumberLong(&quot;1490005705&quot;),</div><div class="line">&quot;IsStepTimeout&quot; : true,</div><div class="line">&quot;StepStartAt&quot; : NumberLong(&quot;1489487036&quot;),</div><div class="line">&quot;StepEndAt&quot; : NumberLong(&quot;1489716666&quot;),</div><div class="line">&quot;StepDuration&quot; : NumberLong(&quot;229630&quot;),</div><div class="line">&quot;Log&quot; : [</div><div class="line">    &quot;2017-03-14 18:23:56\tOrder Processing&quot;,</div><div class="line">    &quot;2017-03-17 10:11:06\tOrder Placed&quot;</div><div class="line">],</div><div class="line">&quot;Compensation&quot; : 2</div><div class="line">&#125;,…</div></pre></td></tr></table></figure>
<h2 id="聚合脚本"><a href="#聚合脚本" class="headerlink" title="聚合脚本"></a>聚合脚本</h2><p>将脚本保存为 distinct.js  ,然后通过  mongo dbip distinct.js 执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">var curdb=db.getSiblingDB(&quot;T24HRCompensation&quot;);</div><div class="line">var rs=curdb.model.T24HRStepStatistics.aggregate([&#123;</div><div class="line">    $sort: &#123;</div><div class="line">    // 先排序，影响聚合结果中data数组的顺序</div><div class="line">        CreateDate: 1</div><div class="line">    &#125;</div><div class="line">&#125;, &#123;</div><div class="line">	// 分组</div><div class="line">    $group: &#123;</div><div class="line">    	// 以 orderid 和stepname 两个维度分组，相当于两个字段联合唯一</div><div class="line">        _id: &#123;</div><div class="line">            &quot;orderId&quot;: &quot;$OrderId&quot;,</div><div class="line">            &quot;stepName&quot;: &quot;$Step&quot;</div><div class="line">        &#125;,</div><div class="line">        // 统计分组中条目数</div><div class="line">        count: &#123;</div><div class="line">            $sum: 1</div><div class="line">        &#125;,</div><div class="line">        // 将 $$ROOT(表示源数据，这里是每一分组中的数据)</div><div class="line">        data: &#123;</div><div class="line">        	// 将源数据放到data数组中</div><div class="line">            $push: &apos;$$ROOT&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, &#123;</div><div class="line">	// 最终筛选条件，影响哪些分组数据显示出来</div><div class="line">    $match: &#123;</div><div class="line">        count: &#123;</div><div class="line">            $gt: 1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;],</div><div class="line">	&#123;</div><div class="line">		// mongodb  aggregate 会限制文档不大于16MB</div><div class="line">		// 这个选项可以将聚合数据写到 dbpath下的tmp文件中，当做临时缓存，而不是都放在内存中。</div><div class="line">		allowDiskUse: true</div><div class="line">	&#125;</div><div class="line">);</div><div class="line">// cursor 遍历</div><div class="line">rs.forEach(function(myDoc) &#123;</div><div class="line">    var n = myDoc.count;</div><div class="line">    var id = myDoc._id;</div><div class="line">    var data = myDoc.data;</div><div class="line">    print(n,id.stepName)</div><div class="line">    for (var i = 1;i &lt; n;i++)&#123;</div><div class="line">    	// 删除除了最早创建的数据以外的所有重复数据</div><div class="line">		curdb.model.T24HRStepStatistics.remove(&#123;_id:data[i]._id&#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="结果-amp-总结"><a href="#结果-amp-总结" class="headerlink" title="结果&amp;总结"></a>结果&amp;总结</h2><p>第一次运行，提示 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Error: Printing Stack Trace</div><div class="line">    at printStackTrace (src/mongo/shell/utils.js:37:15)</div><div class="line">    at DBCollection.aggregate (src/mongo/shell/collection.js:897:9)</div><div class="line">    at (shell):1:30</div><div class="line">Wed Mar 29 14:51:16.315 aggregate failed: &#123;</div><div class="line">  &quot;errmsg&quot; : &quot;exception: Sort exceeded memory limit of 104857600 bytes, but did not opt in to external sorting. Aborting operation. Pass allowDiskUse:true to opt in.&quot;,</div><div class="line">  &quot;code&quot; : 16819,</div><div class="line">  &quot;ok&quot; : 0</div><div class="line">&#125; at src/mongo/shell/collection.js:898</div></pre></td></tr></table></figure>
<p>由于没有对 sort字段建立索引，建立后，重新运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Error: Printing Stack Trace</div><div class="line">    at printStackTrace (src/mongo/shell/utils.js:37:15)</div><div class="line">    at DBCollection.aggregate (src/mongo/shell/collection.js:897:9)</div><div class="line">    at (shell):1:30</div><div class="line">Wed Mar 29 15:19:37.383 aggregate failed: &#123;</div><div class="line">  &quot;errmsg&quot; : &quot;exception: Exceeded memory limit for $group, but didn&apos;t allow external sort. Pass allowDiskUse:true to opt in.&quot;,</div><div class="line">  &quot;code&quot; : 16945,</div><div class="line">  &quot;ok&quot; : 0</div><div class="line">&#125; at src/mongo/shell/collection.js:898</div></pre></td></tr></table></figure>
<p>可以看到  sort 的内存限制问题没有再出现，但是分组内存限制问题出现了，这时候 添加 allowDiskUse:true 选项后得到解决。 另： sort 不支持外部sort ，要到db本机去执行上述命令。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://docs.mongodb.com/manual/reference/command/aggregate/" target="_blank" rel="external">mongo docs</a></li>
<li><a href="http://www.cnblogs.com/cswuyg/p/4595799.html" target="_blank" rel="external">mongodb 使用小结</a></li>
<li><a href="http://www.cnblogs.com/viaiu/p/4848445.html" target="_blank" rel="external">mongodb 聚合报错</a></li>
<li><a href="http://www.runoob.com/mongodb/mongodb-aggregate.html" target="_blank" rel="external">mongodb 聚合</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;需求：删除mongodb中重复的“阶段数据”,阶段表中大概有近百万数据。&lt;/p&gt;
&lt;p&gt;方案：按照 “orderi
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="数据库" scheme="https://yeqianming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongo" scheme="https://yeqianming.github.io/tags/mongo/"/>
    
      <category term="工程实践" scheme="https://yeqianming.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>golang internal package</title>
    <link href="https://yeqianming.github.io/2017/03/07/golang-internal-package/"/>
    <id>https://yeqianming.github.io/2017/03/07/golang-internal-package/</id>
    <published>2017-03-07T08:47:41.000Z</published>
    <updated>2017-03-07T09:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>go internal  包，一种安全隔离机制，可以保证内部包只被特定的引用，而不是任何其他包都可以引用。</p>
<p><strong>规则</strong> ： 如果导入代码位于“internal”目录的父目录为根的树外部，则无法导入包含internal的路径的包。</p>
<p><strong>例子</strong></p>
<blockquote>
<p>/a/b/c/internal/d/e 中代码只能被以 /a/b/c 为根目录的树中代码导入。</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit" target="_blank" rel="external">Go 1.4 internal packages</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;go internal  包，一种安全隔离机制，可以保证内部包只被特定的引用，而不是任何其他包都可以引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="go" scheme="https://yeqianming.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>vim 查找</title>
    <link href="https://yeqianming.github.io/2017/03/03/vim-%E6%9F%A5%E6%89%BE/"/>
    <id>https://yeqianming.github.io/2017/03/03/vim-查找/</id>
    <published>2017-03-03T07:59:04.000Z</published>
    <updated>2017-03-03T08:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="普通查找"><a href="#普通查找" class="headerlink" title="普通查找"></a>普通查找</h3><blockquote>
<p>cmd: / 向后查找 </p>
<p>cmd: ? 向前查找</p>
</blockquote>
<h3 id="全词匹配"><a href="#全词匹配" class="headerlink" title="全词匹配"></a>全词匹配</h3><blockquote>
<p>cmd: word\&gt;  后缀匹配</p>
<p>cmd: \&lt;word  前缀匹配</p>
<p>cmd: \&lt; word \&gt; 全词匹配</p>
</blockquote>
<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><blockquote>
<p>cmd:  :set ignorecase  // 忽略大小写</p>
<p>cmd: :set noignorecase  // 恢复大小写敏感</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;普通查找&quot;&gt;&lt;a href=&quot;#普通查找&quot; class=&quot;headerlink&quot; title=&quot;普通查找&quot;&gt;&lt;/a&gt;普通查找&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;cmd: / 向后查找 &lt;/p&gt;
&lt;p&gt;cmd: ? 向前查找&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="vim" scheme="https://yeqianming.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>shell shift</title>
    <link href="https://yeqianming.github.io/2017/02/28/shell-shift/"/>
    <id>https://yeqianming.github.io/2017/02/28/shell-shift/</id>
    <published>2017-02-28T13:11:41.000Z</published>
    <updated>2017-02-28T13:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    shift 命令用于对参数进行左移，可以在循环遍历控制参数数的递减，也可以去掉左边不需要的参数。shift 命令每执行一次，参数数减一，参数位置依次左移一位，比如之前的 $1 被清除，$2变成$1。同理 shift n 表示前n位参数被清除。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__contains_word()</div><div class="line">&#123;</div><div class="line">    echo $@</div><div class="line">    local w word=$0; shift</div><div class="line">    echo $@</div><div class="line">    for w in &quot;$@&quot;; do</div><div class="line">         echo $w</div><div class="line">        [[ $w = &quot;$word&quot; ]] &amp;&amp; return</div><div class="line">    done</div><div class="line">    return 1</div><div class="line">&#125;</div><div class="line">__contains_word aaa aaaf ddd xxx eee</div></pre></td></tr></table></figure>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出</strong>：</h3><blockquote>
<p>aaa aaaf ddd xxx eee<br>aaaf ddd xxx eee<br>aaaf<br>ddd<br>xxx<br>eee</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​    shift 命令用于对参数进行左移，可以在循环遍历控制参数数的递减，也可以去掉左边不需要的参数。shift 命令每执行一次，参数数
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="shell" scheme="https://yeqianming.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>golang cookieJar</title>
    <link href="https://yeqianming.github.io/2017/02/15/golang-cookieJar/"/>
    <id>https://yeqianming.github.io/2017/02/15/golang-cookieJar/</id>
    <published>2017-02-15T13:16:33.000Z</published>
    <updated>2017-02-15T13:21:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h2><p>当完成登录后，会从服务端response获取到cookie，其中包含了鉴权准入等信息。在后续的请求的cookie加入该信息后，便可以直接访问需要登录过的权限的其他服务api。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>可以使用 <a href="https://golang.org/pkg/net/http/cookiejar/" target="_blank" rel="external">CookieJar</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &quot;net/http/cookiejar&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var client http.Client</div><div class="line">    jar, err := cookiejar.New(nil)</div><div class="line">    if err != nil &#123;</div><div class="line">        panic(err)</div><div class="line">    &#125;</div><div class="line">    client.Jar = jar</div><div class="line"></div><div class="line">    client.Post(...) // 在这里登陆</div><div class="line">    client.Get()     // 后续请求client会自动将cookie加入</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用情景&quot;&gt;&lt;a href=&quot;#使用情景&quot; class=&quot;headerlink&quot; title=&quot;使用情景&quot;&gt;&lt;/a&gt;使用情景&lt;/h2&gt;&lt;p&gt;当完成登录后，会从服务端response获取到cookie，其中包含了鉴权准入等信息。在后续的请求的cookie加入该信息后
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="go" scheme="https://yeqianming.github.io/tags/go/"/>
    
      <category term="web" scheme="https://yeqianming.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>赋值的原子性讨论</title>
    <link href="https://yeqianming.github.io/2017/02/15/%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E8%AE%A8%E8%AE%BA/"/>
    <id>https://yeqianming.github.io/2017/02/15/赋值的原子性讨论/</id>
    <published>2017-02-15T09:09:40.000Z</published>
    <updated>2017-02-15T09:34:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>转载自csdn博客</code> <a href="http://blog.csdn.net/yfkiss/article/details/7450467" target="_blank" rel="external">C语言赋值语句是不是原子操作？</a> </p>
<blockquote>
<p>经常看到有同学讨论，C语言的赋值语句是不是原子操作？C语言的++语句是不是原子操作？</p>
</blockquote>
<p><strong>webopedia</strong>:</p>
<p>Atomic implies indivisibility and irreducibility, so an atomic operation must be performed entirely or not performed at all.An operation during which a processor can simultaneously read a location and write it <strong>in the same bus operation</strong>. This prevents any other processor or I/O device from writing or reading memory until the operation is complete.</p>
<p><strong>osdev</strong>:<br><strong>An atomic operation is an operation that will always be executed without any other process being able to read or change state that is read or changed during the operation.</strong> It is effectively executed as a single step, and is an important quality in a number of algorithms that deal with multiple indepent processes, both in synchronization and algorithms that update shared data without requiring synchronization.</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="时钟周期、总线周期和指令周期"><a href="#时钟周期、总线周期和指令周期" class="headerlink" title="时钟周期、总线周期和指令周期"></a>时钟周期、总线周期和指令周期</h3><ul>
<li>1.时钟周期：微处理器执行指令的最小时间单位，又称T状态。它通常与微机的主频有关。</li>
<li>2.总线周期：CPU对存储器或I/O端口完成一次读/写操作所需的时间。如8086微处理器的基本总线周期由四个时钟周期T1～T4组成，80486微处理器的基本总线周期由T1和T2两个时钟周期组成。当外设速度较慢时，可插入等待周期Tw。</li>
<li>3.指令周期：CPU执行一条指令所需要的时间。<strong>指令周期由若干个总线周期组成</strong>，不同指令执行的时间不同。同一功能的指令，在寻址方式不同时，所需要的时间也不同。</li>
</ul>
<h3 id="总线操作周期"><a href="#总线操作周期" class="headerlink" title="总线操作周期"></a>总线操作周期</h3><p>微机系统各部件之间的信息交换是通过总线操作周期完成的，一个总线周期通常分为以下四个阶段。</p>
<ul>
<li>1.总线请求和仲裁阶段：当有多个模块提出总线请求时，必须由仲裁机构仲裁，确定将总线的使用权分配给哪个模块。</li>
<li>2.寻址阶段：取得总线使用权的模块，经总线发出本次要访问的存储器或I/O端口的地址和有关命令。</li>
<li>3.传送数据阶段：主模块（指取得总线控制权的模块）与其他模块之间进行数据的传送。</li>
<li>4.结束阶段：主模块将有关信息从总线上撤除，主模块交出对总线的控制权。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>CPU最小的执行单元是指令，一个指令周期可能包括多个总线周期。</strong><br>我们可以得到：</p>
<ul>
<li><strong>1. 在单处理器下，一个操作只包括一个cpu指令可以保证是原子操作。如果一个操作包含多个cpu指令不是原子操作。</strong></li>
<li><strong>2. 在多处理器下，由于一个cpu指令周期可能包含多个总线周期，就有可能出现其他处理器在一个指令执行期间访问了其相关的状态。因此，多处理器下，指令执行期间还必须锁总线，才能保证CPU指令的原子性</strong></li>
</ul>
<p>我们看下C语言的赋值和++操作<br>代码main.c：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">	void fun1()  &#123;          </div><div class="line">	volatile int m;         </div><div class="line">	volatile int n;          </div><div class="line">	m = 99;         </div><div class="line">	n = m;  </div><div class="line">&#125;    </div><div class="line">void fun2()  &#123;          </div><div class="line">	volatile int n = 10;          </div><div class="line">	n++;  </div><div class="line">&#125;    </div><div class="line">int main(int argc, char** argv)  &#123;          </div><div class="line">	fun();            </div><div class="line">	return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 汇编：gcc -S main.c<br>查看fun1相关的指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pushq   %rbp       </div><div class="line">  movq    %rsp, %rbp  </div><div class="line">  movl    $99, -4(%rbp)   </div><div class="line">  movl    -4(%rbp), %eax   </div><div class="line">  movl    %eax, -8(%rbp) </div><div class="line">  leave</div></pre></td></tr></table></figure>
<p>  fun2相关指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pushq   %rbp  </div><div class="line">  movq    %rsp, %rbp </div><div class="line">  movl    $10, -4(%rbp)</div><div class="line">  leaq    -4(%rbp), %rax</div><div class="line">  incl    (%rax)</div><div class="line">  movl    %eax, -4(%rbp)</div><div class="line">  leave</div></pre></td></tr></table></figure>
<p>可以看到，n = m为两条指令：<br>        movl    -4(%rbp), %eax<br>        movl    %eax, -8(%rbp)</p>
<p>n++三条指令：<br>         leaq    -4(%rbp), %rax<br>         incl    (%rax)<br>         movl    %eax, -4(%rbp)<br>都是多条指令，所以，不是原子操作。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>原子操作和硬件实现、编译器实现都紧密相关，因此，单纯的在高级语言的层次讨论原子操作，没有太大的意义。</strong></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://wiki.osdev.org/Atomic_operation" target="_blank" rel="external">http://wiki.osdev.org/Atomic_operation</a><br><a href="http://www.webopedia.com/TERM/A/atomic_operation.html" target="_blank" rel="external">http://www.webopedia.com/TERM/A/atomic_operation.html</a><br><a href="http://www.chinaunix.net/jh/23/804826.html" target="_blank" rel="external">http://www.chinaunix.net/jh/23/804826.html</a><br><a href="http://odetocode.com/blogs/scott/archive/2006/05/17/atomic-operations.aspx" target="_blank" rel="external">http://odetocode.com/blogs/scott/archive/2006/05/17/atomic-operations.aspx</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;转载自csdn博客&lt;/code&gt; &lt;a href=&quot;http://blog.csdn.net/yfkiss/article/details/7450467&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;C语言赋值语句是不是原子操作？&lt;/a&gt; &lt;
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="概念" scheme="https://yeqianming.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="C" scheme="https://yeqianming.github.io/tags/C/"/>
    
      <category term="内核" scheme="https://yeqianming.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>go 连接池实现</title>
    <link href="https://yeqianming.github.io/2017/02/15/go-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    <id>https://yeqianming.github.io/2017/02/15/go-连接池实现/</id>
    <published>2017-02-15T08:00:13.000Z</published>
    <updated>2017-02-15T09:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="连接池概述"><a href="#连接池概述" class="headerlink" title="连接池概述"></a>连接池概述</h2><p>连接池可以看做是一个维护了若干连接的一个池子。需要则从其中拿取连接，用完则放回去。</p>
<p>使用连接池可以提升资源的利用率，复用之前使用过的连接，节省创建关闭连接的时间成本，也可以防止出现大量建立连接而对资源的浪费等.也可防止频繁关闭连接出现的 TIME-WAIT 状态的连接。</p>
<h2 id="连接池需要的特性"><a href="#连接池需要的特性" class="headerlink" title="连接池需要的特性"></a>连接池需要的特性</h2><ul>
<li>keeplive ，保持连接</li>
<li>maxCap ，可设置最大连接数</li>
<li>可以释放失效连接</li>
<li>(可选) io超时处理</li>
<li>(可选) 连接超时</li>
<li>one-retry</li>
<li>并发安全</li>
</ul>
<h2 id="连接池实现-fatih-pool-项目地址"><a href="#连接池实现-fatih-pool-项目地址" class="headerlink" title="连接池实现  fatih/pool 项目地址"></a>连接池实现  <a href="https://github.com/fatih/pool" target="_blank" rel="external">fatih/pool 项目地址</a></h2><h3 id="Pool-接口"><a href="#Pool-接口" class="headerlink" title="Pool 接口"></a>Pool 接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">type Pool interface &#123;</div><div class="line">	//获取连接</div><div class="line">	Get() (net.Conn, error)</div><div class="line">	Close()</div><div class="line">	Len() int</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Pool-实现-channelPool"><a href="#Pool-实现-channelPool" class="headerlink" title="Pool 实现 channelPool"></a>Pool 实现 channelPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//连接池的实现</div><div class="line">type channelPool struct &#123;</div><div class="line">	mu    sync.Mutex</div><div class="line">	conns chan net.Conn</div><div class="line"></div><div class="line">	//生成 net.Conn</div><div class="line">	factory Factory</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="初始化pool"><a href="#初始化pool" class="headerlink" title="初始化pool"></a>初始化pool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//初始化 Pool</div><div class="line">func NewChannelPool(initialCap, maxCap int, factory Factory) (Pool, error) &#123;</div><div class="line">	if initialCap &lt; 0 || maxCap &lt;= 0 || initialCap &gt; maxCap &#123;</div><div class="line">		return nil, errors.New(&quot;invalid capacity settings&quot;)</div><div class="line">	&#125;</div><div class="line">	c := &amp;channelPool&#123;</div><div class="line">		conns:   make(chan net.Conn, maxCap),</div><div class="line">		factory: factory,</div><div class="line">	&#125;</div><div class="line">	//根据参数 初始化池中idle连接</div><div class="line">	for i := 0; i &lt; initialCap; i++ &#123;</div><div class="line">		conn, err := factory()</div><div class="line">		if err != nil &#123;</div><div class="line">			//有一个连接创建失败，则调用pool的close方法，关闭所有的连接</div><div class="line">			c.Close()</div><div class="line">			return nil, fmt.Errorf(&quot;factory is not able to fill the pool:%s&quot;, err)</div><div class="line">		&#125;</div><div class="line">		//放入连接池中</div><div class="line">		c.conns &lt;- conn</div><div class="line">	&#125;</div><div class="line">	return c, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="从池中取连接"><a href="#从池中取连接" class="headerlink" title="从池中取连接"></a>从池中取连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func (c *channelPool) Get() (net.Conn, error) &#123;</div><div class="line">	conns := c.getConns()</div><div class="line">	if conns == nil &#123;</div><div class="line">		return nil, ErrClosed</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	select &#123;</div><div class="line">	//从池中获取连接</div><div class="line">	case conn := &lt;-conns:</div><div class="line">		//连接为nil 则说明 channel Pool 已经关闭</div><div class="line">		if conn == nil &#123;</div><div class="line">			return nil, ErrClosed</div><div class="line">		&#125;</div><div class="line">		return c.wrapConn(conn), nil</div><div class="line">	default:</div><div class="line">		// pool 中没有空闲的连接，直接申请新的连接</div><div class="line">		conn, err := c.factory()</div><div class="line">		if err != nil &#123;</div><div class="line">			return nil, err</div><div class="line">		&#125;</div><div class="line">		return c.wrapConn(conn), nil</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="将连接放回池中"><a href="#将连接放回池中" class="headerlink" title="将连接放回池中"></a>将连接放回池中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 关闭连接时，调用放入连接到池中</div><div class="line">func (c *channelPool) put(conn net.Conn) error &#123;</div><div class="line">	if conn == nil &#123;</div><div class="line">		return errors.New(&quot;connection is nil. rejecting&quot;)</div><div class="line">	&#125;</div><div class="line">	c.mu.Lock()</div><div class="line">	defer c.mu.Unlock()</div><div class="line">	if c.conns == nil &#123;</div><div class="line">		//pool 关闭则直接关闭</div><div class="line">		return conn.Close()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	select &#123;</div><div class="line">	// 放不进去，说明pool 已满</div><div class="line">	case c.conns &lt;- conn:</div><div class="line">		return nil</div><div class="line">		// 如果pool 已满，那么直接关闭连接</div><div class="line">	default:</div><div class="line">		return conn.Close()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="关闭pool"><a href="#关闭pool" class="headerlink" title="关闭pool"></a>关闭pool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func (c *channelPool) Close() &#123;</div><div class="line">	c.mu.Lock()</div><div class="line">	conns := c.conns</div><div class="line">	//快速清空pool</div><div class="line">	c.conns = nil</div><div class="line">	c.factory = nil</div><div class="line">	c.mu.Unlock()</div><div class="line"></div><div class="line">	if conns == nil &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	close(conns)</div><div class="line">	//一次关闭连接</div><div class="line">	for conn := range conns &#123;</div><div class="line">		conn.Close()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取-pool"><a href="#获取-pool" class="headerlink" title="获取 pool"></a>获取 pool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//并发安全,比如其他协程正好关闭pool，读取时发生竞争</div><div class="line">func (c *channelPool) getConns() chan net.Conn &#123;</div><div class="line">	c.mu.Lock()</div><div class="line">	conns := c.conns</div><div class="line">	c.mu.Unlock()</div><div class="line">	return conns</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连接包装-PoolConn"><a href="#连接包装-PoolConn" class="headerlink" title="连接包装 PoolConn"></a>连接包装 PoolConn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">type PoolConn struct &#123;</div><div class="line">	net.Conn</div><div class="line">	mu       sync.RWMutex</div><div class="line">	c        *channelPool</div><div class="line">	unusable bool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="包装连接及关闭方法"><a href="#包装连接及关闭方法" class="headerlink" title="包装连接及关闭方法"></a>包装连接及关闭方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 将pool 和 conn关联起来</div><div class="line">func (c *channelPool) wrapConn(conn net.Conn) net.Conn &#123;</div><div class="line">	p := &amp;PoolConn&#123;c: c&#125;</div><div class="line">	p.Conn = conn</div><div class="line">	return p</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//重新实现close，关闭连接 优先会尝试放回pool 中</div><div class="line">func (p *PoolConn) Close() error &#123;</div><div class="line">	p.mu.RLock()</div><div class="line">	defer p.mu.RUnlock()</div><div class="line">	//若连接不可用 则直接调用conn的底层关闭方法</div><div class="line">	if p.unusable &#123;</div><div class="line">		if p.Conn != nil &#123;</div><div class="line">			return p.Conn.Close()</div><div class="line">		&#125;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	return p.c.put(p.Conn)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="标记不可用连接-MarkUnusable"><a href="#标记不可用连接-MarkUnusable" class="headerlink" title="标记不可用连接 MarkUnusable"></a>标记不可用连接 MarkUnusable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func (p *PoolConn) MarkUnusable() &#123;</div><div class="line">	p.mu.Lock()</div><div class="line">	p.unusable = true</div><div class="line">	p.mu.Unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;连接池概述&quot;&gt;&lt;a href=&quot;#连接池概述&quot; class=&quot;headerlink&quot; title=&quot;连接池概述&quot;&gt;&lt;/a&gt;连接池概述&lt;/h2&gt;&lt;p&gt;连接池可以看做是一个维护了若干连接的一个池子。需要则从其中拿取连接，用完则放回去。&lt;/p&gt;
&lt;p&gt;使用连接池可以提升
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="go" scheme="https://yeqianming.github.io/tags/go/"/>
    
      <category term="网络" scheme="https://yeqianming.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>vim 列编辑模式</title>
    <link href="https://yeqianming.github.io/2017/02/14/vim-%E5%88%97%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yeqianming.github.io/2017/02/14/vim-列编辑模式/</id>
    <published>2017-02-14T07:40:40.000Z</published>
    <updated>2017-02-14T08:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><ul>
<li>光标定位到要操作的地方。</li>
<li>CTRL+v 进入“可视 块”模式，选取这一列操作多少行。</li>
<li>d 删除。</li>
</ul>
<h2 id="插入列"><a href="#插入列" class="headerlink" title="插入列"></a>插入列</h2><p>插入操作的话知识稍有区别。例如我们在每一行前都插入“#”；</p>
<ul>
<li>光标定位到要插入的地方。</li>
<li>ctrl+v 进入 块模式，选择要操作的块。</li>
<li>shift+i  输入要插入的内容</li>
<li>按 esc 两次</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;删除列&quot;&gt;&lt;a href=&quot;#删除列&quot; class=&quot;headerlink&quot; title=&quot;删除列&quot;&gt;&lt;/a&gt;删除列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;光标定位到要操作的地方。&lt;/li&gt;
&lt;li&gt;CTRL+v 进入“可视 块”模式，选取这一列操作多少行。&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="vim" scheme="https://yeqianming.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>状态和无状态服务器</title>
    <link href="https://yeqianming.github.io/2017/02/14/%E7%8A%B6%E6%80%81%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://yeqianming.github.io/2017/02/14/状态和无状态服务器/</id>
    <published>2017-02-14T03:06:03.000Z</published>
    <updated>2017-02-14T07:40:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>对于服务器程序来说，有个基本假设，即服务器是基于状态请求，还是基于无状态请求。根据这个假设，可以将服务器划分为状态服务器和无状态服务器。</p>
</blockquote>
<h2 id="状态服务器"><a href="#状态服务器" class="headerlink" title="状态服务器"></a>状态服务器</h2><p>如果是状态化请求，那么服务端一般需要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。</p>
<p>状态服务器具有以下特点：<br>- 保存客户请求的数据（状态）<br>- 服务端容易对客户状态进行管理<br>- 服务端并不要求每次客户请求都携带额外的状态数据</p>
<h2 id="无状态服务器"><a href="#无状态服务器" class="headerlink" title="无状态服务器"></a>无状态服务器</h2><p>无状态服务器处理的客户信息必须全部来自于请求所携带的信息以及其他服务器自身所保存的、并且可以被所有请求所使用的公共信息。</p>
<p>无状态服务器具有以下特点：<br>- 并不保存客户请求的数据（状态）<br>- 客户在请求时需要携带额外的状态数据<br>- 无状态服务器更加健壮，重启服务器不会丢失状态信息，这使得维护和扩容更加简单</p>
<p>无状态的服务器程序，最著名的就是WEB服务器。<br>每次HTTP请求和以前请求没有直接关联。<br>为了跟踪客户请求的状态信息，请求中加入COOKIE。<br>COOKIE的存在，是无状态化向状态化过渡的一种手段。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/romandion/article/details/1800025" target="_blank" rel="external">状态和无状态－－2种服务器架构之间的比较</a></li>
<li><a href="http://orca.st.usm.edu/~seyfarth/network_pgm/net-6-3-3.html" target="_blank" rel="external">Stateless vs Stateful Servers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于服务器程序来说，有个基本假设，即服务器是基于状态请求，还是基于无状态请求。根据这个假设，可以将服务器划分为状态服务器和无状态服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;状态服务器&quot;&gt;&lt;a href=&quot;#状态服务器&quot; class
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="网络" scheme="https://yeqianming.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="web" scheme="https://yeqianming.github.io/tags/web/"/>
    
      <category term="概念" scheme="https://yeqianming.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Tcp连接池</title>
    <link href="https://yeqianming.github.io/2017/02/13/%E8%81%8A%E8%81%8Atcp-%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://yeqianming.github.io/2017/02/13/聊聊tcp-连接池/</id>
    <published>2017-02-13T12:47:41.000Z</published>
    <updated>2017-02-14T07:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.tuicool.com/articles/iI3Ybq7" title="聊聊tcp 连接池" target="_blank" rel="external">转载自推酷</a></p>
<h2 id="概览："><a href="#概览：" class="headerlink" title="概览："></a>概览：</h2><ul>
<li><strong>为什么需要连接池</strong></li>
<li><strong>连接失效问题</strong></li>
<li><strong>database/sql 中的连接池</strong></li>
<li><strong>使用连接池管理Thrift链接</strong></li>
</ul>
<p>以下主要使用Golang作为编程语言</p>
<h2 id="为什么需要连接池"><a href="#为什么需要连接池" class="headerlink" title="为什么需要连接池"></a>为什么需要连接池</h2><p>我觉得使用连接池最大的一个好处就是 <strong>减少连接的创建和关闭，增加系统负载能力</strong> ， 之前就有遇到一个问题： <a href="http://silenceper.com/blog/201601/tcp-time_wait%E8%BF%9E%E6%8E%A5%E6%95%B0%E8%BF%87%E5%A4%9A%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8/" target="_blank" rel="external">TCP TIME_WAIT连接数过多导致服务不可用</a> ，因为未开启数据库连接池，再加上mysql并发较大，导致需要频繁的创建链接，最终产生了上万的TIME_WAIT的tcp链接，影响了系统性能。</p>
<p>链接池中的的功能主要是管理一堆的链接，包括创建和关闭，所以自己在 <a href="https://silenceper.github.io/fatih/pool" target="_blank" rel="external">fatih/pool</a> 基础上，改造了一下： <a href="https://github.com/silenceper/pool" target="_blank" rel="external">https://github.com/silenceper/pool</a> ，使得更加通用一些，增加的一些功能点如下：</p>
<ul>
<li>连接对象不单单是 <code>net.Conn</code> ,变为了 <code>interface{}</code> （池中存储自己想要的格式）</li>
<li>增加了链接的最大空闲时间（保证了当连接空闲太久，链接失效的问题）</li>
</ul>
<p>主要是用到了 <code>channel</code> 来管理连接，并且能够很好的利用管道的顺序性，当需要使用的时候 <code>Get</code> 一个连接，使用完毕之后 <code>Put</code> 放回 <code>channel</code> 中。</p>
<h2 id="连接失效问题"><a href="#连接失效问题" class="headerlink" title="连接失效问题"></a>连接失效问题</h2><p>使用连接池之后就不再是短连接，而是长连接了，就引发了一些问题：</p>
<h4 id="1、长时间空闲，连接断开？"><a href="#1、长时间空闲，连接断开？" class="headerlink" title="1、长时间空闲，连接断开？"></a>1、长时间空闲，连接断开？</h4><p>因为网络环境是复杂的，中间可能因为防火墙等原因，导致长时间空闲的连接会断开，所以可以通过两个方法来解决：</p>
<ul>
<li>客户端增加心跳，定时的给服务端发送请求</li>
<li>给连接池中的连接增加最大空闲时间，超时的连接不再使用</li>
</ul>
<p>在 <a href="https://silenceper.github.io/[https://github.com/silenceper/pool]" target="_blank" rel="external">https://github.com/silenceper/pool</a> 就增加了一个这样最大空闲时间的参数，在连接创建或者连接被重新返回连接池中时重置，给每个连接都增加了一个连接的创建时间，在取出的时候对时间进行比较： <a href="https://github.com/silenceper/pool/blob/master/channel.go#L85" target="_blank" rel="external">https://github.com/silenceper/pool/blob/master/channel.go#L85</a></p>
<h4 id="2、当服务端重启之后，连接失效？"><a href="#2、当服务端重启之后，连接失效？" class="headerlink" title="2、当服务端重启之后，连接失效？"></a>2、当服务端重启之后，连接失效？</h4><p>远程服务端很有可能重启，那么之前创建的链接就失效了。客户端在使用的时候就需要判断这些失效的连接并丢弃，在 <code>database/sql</code> 中就判断了这些失效的连接，使用这种错误表示 <code>var ErrBadConn = errors.New(&quot;driver: bad connection&quot;)</code></p>
<p>另外值得一提的就是在 <code>database/sql</code> 对这种 <code>ErrBadConn</code> 错误进行了重试，默认重试次数是两次，所以能够保证即便是链接失效或者断开了，本次的请求能够正常响应（继续往下看就是分析了）。</p>
<h4 id="连接失效的特征"><a href="#连接失效的特征" class="headerlink" title="连接失效的特征"></a>连接失效的特征</h4><ul>
<li>对连接进行read读操作时，返回 <code>EOF</code> 错误</li>
<li>对连接进行write操作时，返回 <code>write tcp 127.0.0.1:52089-&gt;127.0.0.1:8002: write: broken pipe</code> 错误</li>
</ul>
<h2 id="database-sql-中的连接池"><a href="#database-sql-中的连接池" class="headerlink" title="database/sql 中的连接池"></a>database/sql 中的连接池</h2><p>在 <code>database/sql</code> 中使用连接连接池很简单，主要涉及下面这些配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.SetMaxIdleConns(10) //连接池中最大空闲连接数</div><div class="line">	db.SetMaxOpenConns(20) //打开的最大连接数</div><div class="line">	db.SetConnMaxLifetime(300*time.Second)//连接的最大空闲时间(可选)</div></pre></td></tr></table></figure>
<p>注：如果 <code>MaxIdleConns</code> 大于0并且 <code>MaxOpenConns</code> 小于 <code>MaxIdleConns</code> ,那么会将 <code>MaxIdleConns</code> 置为 <code>MaxIdleConns</code></p>
<p>来看下db这个结构，以及字段相关说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">type DB struct &#123;</div><div class="line">	//具体的数据库实现的interface&#123;&#125;,</div><div class="line">	//例如https://github.com/go-sql-driver/mysql 就注册并并实现了driver.Open方法，主要是在里面实现了一些鉴权的操作</div><div class="line">	driver driver.Driver  </div><div class="line">	//dsn连接</div><div class="line">	dsn    string</div><div class="line">	//在prepared statement中用到</div><div class="line">	numClosed uint64</div><div class="line"></div><div class="line">	mu           sync.Mutex // protects following fields</div><div class="line">	//可使用的空闲的链接</div><div class="line">	freeConn     []*driverConn</div><div class="line">	//用来传递连接请求的管道</div><div class="line">	connRequests []chan connRequest</div><div class="line">	//当前打开的连接数</div><div class="line">	numOpen      int	</div><div class="line">	//当需要创建新的链接的时候，往这个管道中发送一个struct数据，</div><div class="line">	//因为在Open数据库的就启用了一个goroutine执行connectionOpener方法读取管道中的数据</div><div class="line">	openerCh    chan struct&#123;&#125;</div><div class="line">	//数据库是否已经被关闭</div><div class="line">	closed      bool</div><div class="line">	//用来保证锁被正确的关闭</div><div class="line">	dep         map[finalCloser]depSet</div><div class="line">	//stacktrace of last conn&apos;s put; debug only</div><div class="line">	lastPut     map[*driverConn]string </div><div class="line">	//最大空闲连接</div><div class="line">	maxIdle     int                  </div><div class="line">	//最大打开的连接</div><div class="line">	maxOpen     int                    </div><div class="line">	//连接的最大空闲时间</div><div class="line">	maxLifetime time.Duration          </div><div class="line">	//定时清理空闲连接的管道</div><div class="line">	cleanerCh   chan struct&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一个查询数据库的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rows, err := db.Query(&quot;select * from table1&quot;)</div></pre></td></tr></table></figure>
<p>在调用 <code>db.Query</code> 方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func (db *DB) Query(query string, args ...interface&#123;&#125;) (*Rows, error) &#123;</div><div class="line">	var rows *Rows</div><div class="line">	var err error</div><div class="line">	//这里就做了对失效的链接的重试操作</div><div class="line">	for i := 0; i &lt; maxBadConnRetries; i++ &#123;</div><div class="line">		rows, err = db.query(query, args, cachedOrNewConn)</div><div class="line">		if err != driver.ErrBadConn &#123;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if err == driver.ErrBadConn &#123;</div><div class="line">		return db.query(query, args, alwaysNewConn)</div><div class="line">	&#125;</div><div class="line">	return rows, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在什么情况下会返回，可以从这里看到： <a href="https://github.com/go-sql-driver/mysql/blob/master/packets.go#L35" target="_blank" rel="external">readPack</a> ， <a href="https://github.com/go-sql-driver/mysql/blob/master/packets.go#L132" target="_blank" rel="external">writePack</a></p>
<p>继续跟进去就到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func (db *DB) conn(strategy connReuseStrategy) (*driverConn, error) &#123;</div></pre></td></tr></table></figure>
<p>方法主要是创建tcp连接，并判断了连接的生存时间lifetime，以及连接数的一些限制，如果超过的设定的最大打开链接数限制等待 <code>connRequest</code> 管道中有连接产生(在 <code>putConn</code> 释放链接的时候就会往这个管道中写入数据)</p>
<h4 id="何时释放链接"><a href="#何时释放链接" class="headerlink" title="何时释放链接?"></a>何时释放链接?</h4><p>当我们调用 <code>rows.Close()</code> 的时候，就会把当前正在使用的链接重新放回 <code>freeConn</code> 或者写入到 <code>db.connRequests</code> 管道中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//putConnDBLocked 方法</div><div class="line">	</div><div class="line">	//如果有db.connRequests有在等待连接的话，就把当前连接给它用</div><div class="line">	if c := len(db.connRequests); c &gt; 0 &#123;</div><div class="line">		req := db.connRequests[0]</div><div class="line">		// This copy is O(n) but in practice faster than a linked list.</div><div class="line">		// TODO: consider compacting it down less often and</div><div class="line">		// moving the base instead?</div><div class="line">		copy(db.connRequests, db.connRequests[1:])</div><div class="line">		db.connRequests = db.connRequests[:c-1]</div><div class="line">		if err == nil &#123;</div><div class="line">			dc.inUse = true</div><div class="line">		&#125;</div><div class="line">		req &lt;- connRequest&#123;</div><div class="line">			conn: dc,</div><div class="line">			err:  err,</div><div class="line">		&#125;</div><div class="line">		return true</div><div class="line">	&#125; else if err == nil &amp;&amp; !db.closed &amp;&amp; db.maxIdleConnsLocked() &gt; len(db.freeConn) &#123;</div><div class="line">	//没人需要我这个链接，我就把他重新返回`freeConn`连接池中</div><div class="line">		db.freeConn = append(db.freeConn, dc)</div><div class="line">		db.startCleanerLocked()</div><div class="line">		return true</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="使用连接池管理Thrift链接"><a href="#使用连接池管理Thrift链接" class="headerlink" title="使用连接池管理Thrift链接"></a>使用连接池管理Thrift链接</h2><p>这里是使用连接池 <a href="https://github.com/silenceper/pool" target="_blank" rel="external">https://github.com/silenceper/pool</a> ，如何构建一个thrift链接</p>
<p>客户端创建Thrift的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">type Client struct &#123;</div><div class="line">	*user.UserClient</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//创建Thrift客户端链接的方法</div><div class="line">factory := func() (interface&#123;&#125;, error) &#123;</div><div class="line">	protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()</div><div class="line">	transportFactory := thrift.NewTTransportFactory()</div><div class="line"></div><div class="line">	var transport thrift.TTransport</div><div class="line">	var err error</div><div class="line">	transport, err = thrift.NewTSocket(rpcConfig.Listen)</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	transport = transportFactory.GetTransport(transport)</div><div class="line">	//defer transport.Close()</div><div class="line">	if err := transport.Open(); err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	rpcClient := user.NewUserClientFactory(transport, protocolFactory)</div><div class="line">	//在连接池中直接放置Client对象</div><div class="line">	return &amp;Client&#123;UserClient: rpcClient&#125;, nil</div><div class="line">&#125;</div><div class="line">//关闭连接的方法</div><div class="line">close := func(v interface&#123;&#125;) error &#123;</div><div class="line">	v.(*Client).Transport.Close()</div><div class="line">	return nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建了一个 初始化连接是</div><div class="line">poolConfig := &amp;pool.PoolConfig&#123;</div><div class="line">	InitialCap: 10,</div><div class="line">	MaxCap:     20,</div><div class="line">	Factory:     factory,</div><div class="line">	Close:       close,</div><div class="line">	IdleTimeout: 300 * time.Second,</div><div class="line">&#125;</div><div class="line">p, err := pool.NewChannelPool(poolConfig)</div><div class="line">if err != nil &#123;</div><div class="line">	panic(err)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//取得链接</div><div class="line">conn, err := p.Get()</div><div class="line">if err != nil &#123;</div><div class="line">	return nil, err</div><div class="line">&#125;</div><div class="line">v, ok := conn.(*Client)</div><div class="line"></div><div class="line">...使用连接调用远程方法</div><div class="line"></div><div class="line">//将连接重新放回连接池中</div><div class="line">p.Put(conn)</div></pre></td></tr></table></figure>
<p>写完，听见外面的:rooster:开始打鸣了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.tuicool.com/articles/iI3Ybq7&quot; title=&quot;聊聊tcp 连接池&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;转载自推酷&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览：&quot;&gt;&lt;a href=&quot;#概
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="TCP" scheme="https://yeqianming.github.io/tags/TCP/"/>
    
      <category term="网络" scheme="https://yeqianming.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>go位操作</title>
    <link href="https://yeqianming.github.io/2017/02/13/go%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://yeqianming.github.io/2017/02/13/go位操作/</id>
    <published>2017-02-13T08:40:37.000Z</published>
    <updated>2017-02-14T03:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table>
<thead>
<tr>
<th>AND</th>
<th>按位与</th>
<th>a&amp;b</th>
</tr>
</thead>
<tbody>
<tr>
<td>OR</td>
<td>按位或</td>
<td>a 竖杠b</td>
</tr>
<tr>
<td>XOR</td>
<td>异或</td>
<td>a^b</td>
</tr>
<tr>
<td>NOT</td>
<td>按位取反</td>
<td>^a</td>
</tr>
<tr>
<td>AND NOT</td>
<td>按位清除</td>
<td>a&amp;^b</td>
</tr>
<tr>
<td>LEFT SHIFT</td>
<td>左移</td>
<td>a&lt;&lt;1</td>
</tr>
<tr>
<td>RIGHT SHIFT</td>
<td>右移</td>
<td>a&gt;&gt;1</td>
</tr>
</tbody>
</table>
<h2 id="几种实例"><a href="#几种实例" class="headerlink" title="几种实例"></a>几种实例</h2><ul>
<li>变换符号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func nagation(a int) int &#123;</div><div class="line">	return ^a + 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>呼唤变量值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func swap(a, b int) (int, int) &#123;</div><div class="line">	a ^= b</div><div class="line">	b ^= a</div><div class="line">	a ^= b</div><div class="line">	return a, b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>求偶数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func even(a int) (array []int) &#123;</div><div class="line">	for i := 0; i &lt; a; i++ &#123;</div><div class="line">		if i&amp;1 == 0 &#123;</div><div class="line">			array = append(array, i)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return array</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>bitmap 的实现</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;AND&lt;/th&gt;
&lt;th&gt;按位与&lt;/th&gt;
&lt;th&gt;a&amp;amp;b&lt;/th&gt;
&lt;/tr&gt;
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="go" scheme="https://yeqianming.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>下班小聚</title>
    <link href="https://yeqianming.github.io/2017/02/13/%E4%B8%8B%E7%8F%AD%E5%B0%8F%E8%81%9A/"/>
    <id>https://yeqianming.github.io/2017/02/13/下班小聚/</id>
    <published>2017-02-13T04:40:45.000Z</published>
    <updated>2017-02-13T09:31:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    2017年第一周，星期五，工作任务非常少，轻松愉快 :smile: 。所以果断准备约上几个同事，下班一起聚餐潇洒下。</p>
<p>​    在大众点评上找了家评价不错的川菜 –【蜀府】，坐标世博源。发到群里面，小伙伴们纷纷响应报名，大家早早的完成了手头的事，下班准时出发！ 世博源 蜀府 go！</p>
<p>​    蜀府这家餐厅位于奔驰中心，门面精致，宾客云集。随便挑了一张大桌落座，边聊边点菜。菜陆陆续续的上来了，细细品尝。这家菜总体上味道不错，尤其是钵钵鸡、水煮鱼、麻婆豆腐等等，味道正宗。但缺点也是有的，譬如上菜很慢，服务员一直劝你多点些菜，茶水收费等等的。</p>
<p>​    吃饭期间，气氛很活跃，大家各种八卦、段子，层出不穷，其乐融融。不知不觉，两个小时就过去了，于是买单结账走人。</p>
<p>​    路上，看看时间，八点半，大家纷纷嚷着没尽兴，就让凯哥请喝水，找地方坐一坐，结果当凯哥路过一个便利店，转身就要进去买水请客，大家都惊呆了！:scared: 纷纷取笑他抠门， 他招架不住，只好找了家西餐厅，请了档次稍高的酒水。又玩闹了一个小时，大家才各回各家。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/IMG_20170210_204912.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/IMG_20170210_204932.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/IMG_20170210_204936.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    2017年第一周，星期五，工作任务非常少，轻松愉快 :smile: 。所以果断准备约上几个同事，下班一起聚餐潇洒下。&lt;/p&gt;
&lt;p&gt;​    在大众点评上找了家评价不错的川菜 –【蜀府】，坐标世博源。发到群里面，小伙伴们纷纷响应报名，大家早早的完成了手头的事，下班
    
    </summary>
    
      <category term="生活日志" scheme="https://yeqianming.github.io/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="生活" scheme="https://yeqianming.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="聚餐" scheme="https://yeqianming.github.io/tags/%E8%81%9A%E9%A4%90/"/>
    
  </entry>
  
  <entry>
    <title>sqlserver 删除依赖</title>
    <link href="https://yeqianming.github.io/2017/02/10/sqlserver-%E5%88%A0%E9%99%A4%E4%BE%9D%E8%B5%96/"/>
    <id>https://yeqianming.github.io/2017/02/10/sqlserver-删除依赖/</id>
    <published>2017-02-10T08:56:00.000Z</published>
    <updated>2017-02-14T03:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote>
<p>ALTER TABLE DROP COLUMN Areas failed because one or more objects access this column.<br>Msg 5074, Level 16, State 1.<br>The object ‘DF<strong>VoucherTy</strong>Areas__6748398C’ is dependent on column ‘Areas’. (Line 7)</p>
</blockquote>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE Customer DROP CONSTRAINT Con_First;</div></pre></td></tr></table></figure>
<h2 id="eg"><a href="#eg" class="headerlink" title="eg."></a>eg.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table vouchertype drop consTRAINT DF__VoucherTy__Areas__6748398C;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ALTER TABLE DROP COLUMN Areas failed because 
    
    </summary>
    
      <category term="技术博客" scheme="https://yeqianming.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="数据库" scheme="https://yeqianming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQLSERVER" scheme="https://yeqianming.github.io/tags/SQLSERVER/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yeqianming.github.io/2017/02/07/hello-world/"/>
    <id>https://yeqianming.github.io/2017/02/07/hello-world/</id>
    <published>2017-02-07T06:22:00.000Z</published>
    <updated>2017-02-10T16:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed enim turpis, sodales ac ullamcorper quis, blandit sed augue. Vivamus eu tortor id elit suscipit convallis. Nam lorem nunc, tristique eget mattis eget, pharetra in est. Pellentesque ac nisi nulla, et vulputate lectus. Ut egestas sodales tortor, vel fringilla mauris ornare quis. Ut nunc nulla, blandit id laoreet facilisis, lobortis eget mauris. Morbi lorem urna, ornare condimentum faucibus at, ullamcorper non turpis.</p>
<p><em>All the world’s a stage, and all the men and women merely players: they have their exits and their entrances; and one man in his time plays many parts…</em></p>
<p><strong>William Shakespeare*</strong>As You Like It*</p>
<p>Ut dui velit, dapibus vitae scelerisque id, tincidunt vel arcu. Aenean ornare leo in orci pretium eu porttitor nibh venenatis. Curabitur rutrum dolor ac sapien vestibulum interdum in ut felis. Cras ut nisl justo. Suspendisse a lectus enim, vel rutrum urna. Morbi eget sem dui, ac consectetur turpis. Vestibulum ultrices ornare augue at bibendum. Etiam viverra ligula leo. Vestibulum eleifend nulla id leo convallis at bibendum lacus hendrerit. Maecenas placerat feugiat urna, gravida dignissim odio ultrices nec. Maecenas quis adipiscing erat.</p>
<p>Phasellus vitae dui a nulla faucibus tincidunt. Nam tempor vestibulum scelerisque. In id libero arcu, nec tincidunt metus. Praesent eu placerat diam. Cras et diam nec augue sagittis mollis. Ut dignissim tempus lectus. Cras pulvinar enim in libero interdum a euismod risus scelerisque. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Vestibulum vel quam vel ante laoreet vestibulum. Nullam porttitor vehicula tellus, sed adipiscing quam eleifend vel. Integer eget ipsum nibh. Ut tellus nisl, ornare ut ultrices vel, ullamcorper eu nisl. Nunc sed nibh mauris, nec dictum justo.</p>
<p><em>He was not of an age, but for all time.</em></p>
<p>Mauris pulvinar purus sit amet felis scelerisque pharetra. Vestibulum tempor est et metus dapibus ut scelerisque augue sollicitudin. Aliquam erat volutpat. Integer quis nunc sapien, non sodales odio. Fusce quis elementum odio. Vestibulum sed porttitor sapien. Aenean accumsan metus sed dolor tincidunt tincidunt. Quisque neque turpis, semper volutpat convallis ut, sagittis ut nibh. Nunc quis erat eget tortor facilisis pretium. Sed non augue in orci consectetur egestas sit amet mattis dolor. Proin blandit, erat sed ultricies eleifend, orci elit condimentum risus, sit amet adipiscing diam augue sit amet massa. Nulla a diam lectus. Aenean nisl tortor, pulvinar in congue at, ullamcorper in metus. Vestibulum eros dolor, tristique ac iaculis sit amet, tempor ut magna. Maecenas venenatis sapien quis lectus tristique bibendum.</p>
<p>Donec ultrices tincidunt commodo. Pellentesque euismod tempor felis vitae viverra. Ut luctus nulla vitae dolor placerat sit amet accumsan nulla dictum. Etiam scelerisque accumsan lectus ac ultricies. Donec at urna ut leo rutrum viverra. Ut sed justo orci. Morbi non arcu faucibus nibh eleifend ullamcorper.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
